package context

// 引出：在主协程中，如果我们希望对开启的子协程进行一个超时的控制
// 一般会采用一个通道，定义一段监听该通道，并在接收到通道数据后视主协程认为程序需要终止，进行子协程关闭的逻辑
// 假如，子协程中还开启了协程，希望主协程的超时操作对“孙子”协程起作用的同时，子协程对孙子协程还有单独的操作逻辑控制
// 那么这样，就需要再开启一个通道，用于子协程和孙子协程的超时操作，那么孙子协程就需要监听两个通道了，两个都还好，要是再多，程序逻辑就会变得非常混乱

// 上面是博客文章的引出观点，用自己的话说就是，虽然真实的需要子协程中开启子协程的情况少之又少，但是就说说道理，上面这样的方式，明显没有拓展性了
// 真的有这样的业务逻辑需求，也不能采用上面的方式

// 综上，就是说需要一种类似树型的概念，终结某一层，下面的会被取消，而 GO 中的 context 机制或者说模式可以实现

// 说法二：
// 1、web 编程中，一个请求对应多个 goroutine 之间的数据交互
// 2、超时控制
// 3、上下文控制

func _() {
	// 核心接口 context.Context

	// 实现类0：context.emptyCtx 没有超时时间、不能取消、不存储额外信息，用来作为 context 树的根节点
	// 一般不直接使用，而是通过该结构体的 Background() TODO() 等方法来获取接口实现实例（详见源码）

	// 实现类1：cancelCtx
	// 继承自 context，同时也实现了 Context 接口
	// WithCancel()：获取一个可取消的 context - cancelCtx

	// 实现类2：timerCtx
	// 增加了 timeout 机制
	// WithDeadline()： 返回一个基于 parent 的可取消 context

	// 实现类3：valueCtx
	// 存储键值对的数据
	// WithValue()：用于向 context 添加键值对，注意添加方式是以链状的方法
}

// 返回截止时间 是否有截止时间
// Deadline() (deadline time.Time, ok bool)

// 绑定当前 Context 的任务被取消时，返回一个关闭的 channel；如果 Context 不会被取消，将返回 nil
// Done() <-chan struct{}

// Done 方法返回的通道没有关闭了，返回 nil；如果返回的通道关闭了，返回的 err 会包含原因
// Err() error

// 获取存储的数据
// Value(key interface{}) interface{}
