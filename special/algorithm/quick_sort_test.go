package algorithm

import (
	"testing"
)

func TestQuickSort(t *testing.T) {
	float64Slice := []float64{15.43, 17.78, 18.3, 14.98, 17.93, 16.28, 17.03, 16.45, 18.08, 18.25, 20.61, 16.46, 14.95, 16.74, 17.59, 18.4, 15.16, 17.76, 18.25, 15.03, 13.98, 18.19, 16.22, 14.45, 15.76, 16.01, 17.79, 17.49, 17.45, 14.09, 16.89, 13.2, 18.84, 18.59, 18.59, 19.01, 17.01, 17.58, 16.09, 13.76, 18.05, 14.98, 14.93, 16.01, 15.92, 14.53, 16.32, 16.01, 17.42}

	println(float64Slice)
	QuickSort(float64Slice)
	println(float64Slice)
}

// 快速排序的算法描述
// 定义一个数组的头指针和一个数组的尾指针
// 在整个数组中随便选一个数（一般取第一个），先用一个临时变量将其记录下来，这样可以理解将这个数从数组中指定的格子里挖出来了

// 假定挖出数组第一个元素
// 从尾巴指针开始，向前找一个比挖出来 小或者相等 的数，找到了就将这个数挖出来填到第一个坑里边，这样，前面的坑填上了，然后又多了一个坑
// 然后从头指针开始，向后找一个比挖出来（注意还是第一次挖出来的数） 大或相等 的数，找到了就将这个数填到上面刚挖的坑里
// 上面两个步骤都遵循除了找到了目标的数停下，还有可能是因为遇到了另外一个指针，这时寻找也应该停下
// 当两个指针相遇后，此时两个指针指向的地方就是一个坑，此时将最开始被挖出的数填到这个地方
// （最初被挖出来的数，在经过上面流程后，剩下的坑就是这个数最终的正确位置，理解起来简单也迷惑，最终坑位左边的数都比这个数小或者相等，最终坑位右边的数都比这个数大或者相等）
// （在上面不停挖坑，不停填埋的过程中，头指针或尾指针始终是指向当前坑的位置的）

// 上面的流程时快速排序算法的核心，你也会发现，算法执行完了一轮，就会确定一个数的真正位置
// 接下来我们复用上面的流程，将第一轮确定的数的左边所有的数拉去快速排序，右边的数也拉去快速排序
// 没错这就是经典的快速排序的递归形式，当然，光是这样并没有结束，递归总是讲究局部原理的重复，以及原理必须具备的完整性，即这里还缺少终止条件
// 稍微想想，也不难发现，当分组分到最后，也就是一组里面就一个元素的时候，那么此时就无法按照上面的流程重复了，因为左右两边都没有元素了，那么此时，就应该终止了

// 左边挖一下，右边挖一下，好麻烦啊，不能一下把最终坑左边的数确定么？你可以一直找比初次挖出数小的，那么这样你就要遍历到底，并且遍历完，最终的是你并不知道临界点在哪。从这里边走出来，你会发现这个就是选择排序了...
// 所以这个一定是交替进行的

// 从大到小排序
func QuickSort(intSlice []float64) {
	if len(intSlice) <= 1 {
		return
	}

	start, end := 0, len(intSlice)-1

	casual := intSlice[start]
	for start < end {
		// 目的：找比目标数 大的
		// 注意等号问题：两个内循环不能同时去掉等号，即，当头或者尾指针指向的元素和目标元素相等时，不应该跳出循环移动元素
		// 1、不是降低算法性能的问题
		// 2、假如结合中包含重复元素，这可能会导致直接的死循环，尾元素移到头，头元素移到尾的往复循环
		// 最简单解决这个问题，就是判断元素大小的条件，不会出现相同的情况，那么下边加不加等号，就没有任何影响了
		for start < end && intSlice[end] <= casual {
			end--
		}
		// 如果找到了就把该数填到前面的坑里（如果跳出循环，这个条件还成立，说明是因为另外一个条件跳出循环的）
		if start < end {
			intSlice[start] = intSlice[end]
		}
		for start < end && intSlice[start] >= casual {
			start++
		}
		if start < end {
			intSlice[end] = intSlice[start]
		}
	}
	intSlice[start] = casual

	QuickSort(intSlice[:start])
	QuickSort(intSlice[start+1:])
}

// 点1
// 想把别的数作为第一个被挖坑的数呢，那么这个算法会不会有问题，如果你真的物理上选不是第一个位置的坑，肯定有问题
// 所以想要实现上面的效果，只要将第一个数和你想指定的数换一个位置就可以了

// 点2
// 像上面的快速排序代码实现，完全可以将主方法逻辑体单独抽取到一个函数中，这样快速排序的递归逻辑就可以看的更清晰了

// 点3
// 先说一些
